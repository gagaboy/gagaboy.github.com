<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[问道]]></title>
  <link href="http://gagaboy.github.io/atom.xml" rel="self"/>
  <link href="http://gagaboy.github.io/"/>
  <updated>2014-06-13T22:25:51+08:00</updated>
  <id>http://gagaboy.github.io/</id>
  <author>
    <name><![CDATA[Eric Chang]]></name>
    <email><![CDATA[gagaboy@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【原创译文】创建你的第一个组件（3）]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/13/moquichap10/"/>
    <updated>2014-06-13T22:10:03+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/13/moquichap10</id>
    <content type="html"><![CDATA[<h2>第三步</h2>

<h3>自定义新增服务</h3>

<p>上面的例子里，createTutorial转换使用了隐式的自动实体服务create#Tutorial。我们来看下如何手动的定义和实现一个服务。</p>

<p>首先定义一个服务使用默认的自动实体增删改查（<strong><code>CrUD</code></strong>）实现。将服务定义XML文件放在下面的位置：
<em><code>runtime/component/tutorial/service/tutorial/TutorialServices.xml</code></em></p>

<!--more-->


<p>内容如下：</p>

<figure class='code'><figcaption><span>标准的服务定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;services&gt;</span>
</span><span class='line'>  <span class="nt">&lt;service</span> <span class="na">verb=</span><span class="s">&quot;create&quot;</span> <span class="na">noun=</span><span class="s">&quot;Tutorial&quot;</span> <span class="na">type=</span><span class="s">&quot;entity-auto&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;in-parameters&gt;</span>
</span><span class='line'>          <span class="nt">&lt;auto-parameters</span> <span class="na">include=</span><span class="s">&quot;all&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/in-parameters&gt;</span>
</span><span class='line'>      <span class="nt">&lt;out-parameters&gt;</span>
</span><span class='line'>          <span class="nt">&lt;auto-parameters</span> <span class="na">include=</span><span class="s">&quot;pk&quot;</span> <span class="na">required=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/out-parameters&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/service&gt;</span>
</span><span class='line'><span class="nt">&lt;/services&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个服务将允许Tutorial实体的所有字段传入，并总是返回主键字段（tutorialId）。这个服务定义中我们使用了基于实体的<em><code>auto-parameters</code></em>元素，这样如果我们新增了实体字段的话，它们将自动会体现在这个服务处理中。
现在，我们修改下这个服务定义来添加一个内联的实现。注意下服务中的<strong>type</strong>属性已经发生了变化，并且新增了一个actions元素。</p>

<figure class='code'><figcaption><span>指定主键规则的服务定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;service</span> <span class="na">verb=</span><span class="s">&quot;create&quot;</span> <span class="na">noun=</span><span class="s">&quot;Tutorial&quot;</span> <span class="na">type=</span><span class="s">&quot;inline&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;in-parameters&gt;</span>
</span><span class='line'>      <span class="nt">&lt;auto-parameters</span> <span class="na">include=</span><span class="s">&quot;all&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/in-parameters&gt;</span>
</span><span class='line'>  <span class="nt">&lt;out-parameters&gt;</span>
</span><span class='line'>      <span class="nt">&lt;auto-parameters</span> <span class="na">include=</span><span class="s">&quot;pk&quot;</span> <span class="na">required=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/out-parameters&gt;</span>
</span><span class='line'>    <span class="nt">&lt;actions&gt;</span>
</span><span class='line'>      <span class="nt">&lt;entity-make-value</span> <span class="na">entity-name=</span><span class="s">&quot;Tutorial&quot;</span> <span class="na">value-field=</span><span class="s">&quot;tutorial&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;entity-set</span> <span class="na">value-field=</span><span class="s">&quot;tutorial&quot;</span> <span class="na">include=</span><span class="s">&quot;all&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;if</span> <span class="na">condition=</span><span class="s">&quot;!tutorial.tutorialId&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>          <span class="nt">&lt;entity-sequenced-id-primary</span> <span class="na">value-field=</span><span class="s">&quot;tutorial&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/if&gt;</span>
</span><span class='line'>      <span class="nt">&lt;entity-create</span> <span class="na">value-field=</span><span class="s">&quot;tutorial&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/actions&gt;</span>
</span><span class='line'><span class="nt">&lt;/service&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在只需改变transition指向这个服务既可以调用了：</p>

<figure class='code'><figcaption><span>切换自定义的服务</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;transition</span> <span class="na">name=</span><span class="s">&quot;createTutorial&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;service-call</span> <span class="na">name=</span><span class="s">&quot;tutorial.TutorialServices.create#Tutorial&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;default-response</span> <span class="na">url=</span><span class="s">&quot;.&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/transition&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意下这个服务名称定义很像一个标准的<code>Java class</code>的命名。它有一个“包名”，本例中是在component/service目录下的&#8221;tutorial&#8221;目录（也许是以点号分割的多重目录结构）的目录名。然后是一个点号以及类名的等价物，本例中“TutorialServices”就是服务的XML文件的名称，但是没有.xml后缀。这之后又是一个点号，然后是服务的动词和名词操作，以#符号分割。</p>

<h3>Groovy服务</h3>

<p>如果你想使用Groovy（或者框架支持的其他脚本语言）而不用内联的XML动作去实现服务，怎么做呢？这种情况服务定义像这样：</p>

<figure class='code'><figcaption><span>Groovy服务定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;service</span> <span class="na">verb=</span><span class="s">&quot;create&quot;</span> <span class="na">noun=</span><span class="s">&quot;Tutorial&quot;</span> <span class="na">type=</span><span class="s">&quot;script&quot;</span>
</span><span class='line'>        <span class="na">location=</span><span class="s">&quot;component://tutorial/script/tutorial/createTutorial.groovy&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;in-parameters&gt;</span>
</span><span class='line'>      <span class="nt">&lt;auto-parameters</span> <span class="na">include=</span><span class="s">&quot;all&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/in-parameters&gt;</span>
</span><span class='line'>    <span class="nt">&lt;out-parameters&gt;</span>
</span><span class='line'>        <span class="nt">&lt;auto-parameters</span> <span class="na">include=</span><span class="s">&quot;pk&quot;</span> <span class="na">required=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/out-parameters&gt;</span>
</span><span class='line'><span class="nt">&lt;/service&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意这里服务的type属性已经变为&#8221;script&#8221;，并且现在有个location属性去指定脚本的位置。 <br/>
下面是这个Groovy脚本的内容：</p>

<figure class='code'><figcaption><span>Groovy脚本</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">EntityValue</span> <span class="n">tutorial</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="na">entity</span><span class="o">.</span><span class="na">makeValue</span><span class="o">(</span><span class="s2">&quot;Tutorial&quot;</span><span class="o">)</span>
</span><span class='line'><span class="n">tutorial</span><span class="o">.</span><span class="na">setAll</span><span class="o">(</span><span class="n">context</span><span class="o">)</span>
</span><span class='line'><span class="k">if</span> <span class="o">(!</span><span class="n">tutorial</span><span class="o">.</span><span class="na">tutorialId</span><span class="o">)</span>
</span><span class='line'>  <span class="n">tutorial</span><span class="o">.</span><span class="na">setSequencedIdPrimary</span><span class="o">()</span>
</span><span class='line'><span class="n">tutorial</span><span class="o">.</span><span class="na">create</span><span class="o">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你使用Groovy或者其他语言时，你将会用到基于可执行上下文（<strong><code>ExecutionContext class</code></strong>）这个类去调用Moqui的Java API,通常这个类在脚本里会用&#8221;<strong>ec</strong>&ldquo;这个名称。更多的API详情请看<strong><a href="http://www.moqui.org/javadoc/index.html">Java API文档</a></strong>，并查询文档中<strong><a href="http://www.moqui.org/javadoc/org/moqui/context/ExecutionContext.html">ExecutionContext</a></strong>这个类，这个类关联了很多核心的API接口。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创译文】创建你的第一个组件（2）]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/03/moquichap9/"/>
    <updated>2014-06-03T10:00:54+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/03/moquichap9</id>
    <content type="html"><![CDATA[<h2>第二步</h2>

<h3>我的第一个实体</h3>

<p>实体是一个基本的扁平列表的数据结构，并且通常为数据库中的一张表。一条实体值等价于数据库表的一行记录。Moqui框架没有使用对象关系映射方式，所以我们要做的就是定义一个实体，然后通过实体门面模式（或者其他的高抽象层级的工具）去写代码操作使用实体。</p>

<!--more-->


<p>我们创建一个包含tutorialId和description两个字段的实体XML文件，并命名为“Tutorial”，位于：</p>

<p><em><code>runtime/component/tutorial/entity/TutorialEntities.xml</code></em></p>

<p>内容如下：</p>

<figure class='code'><figcaption><span>Tutorial 实体定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;entities&gt;</span>
</span><span class='line'>  <span class="nt">&lt;entity</span> <span class="na">entity-name=</span><span class="s">&quot;Tutorial&quot;</span> <span class="na">package-name=</span><span class="s">&quot;tutorial&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;field</span> <span class="na">name=</span><span class="s">&quot;tutorialId&quot;</span> <span class="na">type=</span><span class="s">&quot;id&quot;</span> <span class="na">is-pk=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;field</span> <span class="na">name=</span><span class="s">&quot;description&quot;</span> <span class="na">type=</span><span class="s">&quot;text-long&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/entity&gt;</span>
</span><span class='line'><span class="nt">&lt;/entities&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你以开发模式（<strong><em>dev mode</em></strong>）运行Moqui框架，实体定义缓存会自动被清理然后创建，所以你无需重启；但是你如果运行产品模式（<strong><em>production mode</em></strong>）或者你不想等待（Moqui框架启动并不是很快）那么你就重启吧。</p>

<p>你什么时候去创建表呢？除非你关闭自动创建的特性（在Moqui的XML配置文件中有开关），否则实体门面模式将会在你第一次使用到这个实体的时候检查实体是否存在，不存在即会创建它。</p>

<h3>添加一些数据</h3>

<p>实体门面模式具有从XML文件中读取或者写入数据的功能，这些XML文件中的节点元素需要和实体名对应，同样的属性名和字段名需对应。</p>

<p>我们稍后将创建一个用户界面去录入数据，同时你也可以使用自动界面（Auto Screen）或者使用工具应用中的实体数据交互界面（Entity Data UI）和你新建的实体进行数据操作。数据文件对于以下几种数据来说是很有用的：用于代码运行所需的种子数据、测试数据、验证/展示数据模型如何使用的验证数据。那么，我们就开始动手吧。</p>

<p>创建一个实体门面的XML文件在：<em><code>runtime/component/tutorial/data/TutorialData.xml</code></em></p>

<p>内容为：</p>

<figure class='code'><figcaption><span>种子数据</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;entity-facade-xml</span> <span class="na">type=</span><span class="s">&quot;seed&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;Tutorial</span> <span class="na">tutorialId=</span><span class="s">&quot;TestOne&quot;</span> <span class="na">description=</span><span class="s">&quot;Test one description.&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;Tutorial</span> <span class="na">tutorialId=</span><span class="s">&quot;TestTwo&quot;</span> <span class="na">description=</span><span class="s">&quot;Test two description.&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/entity-facade-xml&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>加载数据只要通过“$ ant load”命令即可，或者在“运行Moqui”章节中提及的其他加载方式也可。</p>

<h3>自动查询表单</h3>

<p>在tutorial界面下添加一个子界面的XML定义文件，并将其放到：</p>

<p><em><code>runtime/component/tutorial/screen/tutorial/FindTutorial.xml</code></em></p>

<figure class='code'><figcaption><span>查询表单定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;screen</span> <span class="na">require-authentication=</span><span class="s">&quot;anonymous-view&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;transition</span> <span class="na">name=</span><span class="s">&quot;findTutorial&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;default-response</span> <span class="na">url=</span><span class="s">&quot;.&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/transition&gt;</span>
</span><span class='line'>  <span class="nt">&lt;actions&gt;</span>
</span><span class='line'>      <span class="nt">&lt;entity-find</span> <span class="na">entity-name=</span><span class="s">&quot;Tutorial&quot;</span> <span class="na">list=</span><span class="s">&quot;tutorialList&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>          <span class="nt">&lt;search-form-inputs/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/entity-find&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/actions&gt;</span>
</span><span class='line'>  <span class="nt">&lt;widgets&gt;</span>
</span><span class='line'>      <span class="nt">&lt;form-list</span> <span class="na">name=</span><span class="s">&quot;ListTutorials&quot;</span> <span class="na">list=</span><span class="s">&quot;tutorialList&quot;</span>
</span><span class='line'>                  <span class="na">transition=</span><span class="s">&quot;findTutorial&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>          <span class="nt">&lt;auto-fields-entity</span> <span class="na">entity-name=</span><span class="s">&quot;Tutorial&quot;</span>
</span><span class='line'>                              <span class="na">field-type=</span><span class="s">&quot;find-display&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/form-list&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/widgets&gt;</span>
</span><span class='line'><span class="nt">&lt;/screen&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个界面中有几个关键部分：</p>

<ul>
<li>转换 transition
转换/跳转指的是界面之间的链接。类似于一个顺序图一样，我们把每个界面当成一个个节点，那么界面中定义的转换/跳转就是“线”一般，从一个节点界面指向另外一个节点界面（或者自己指向自己），并且同时有些跳转还包含调用动作或者服务。</li>
</ul>


<blockquote><ul>
<li><p>单个转换可以按照条件或者不同的错误结果返回各种响应页面，一切都取决于你的界面设计需求</p></li>
<li><p>个别转换会指向当前页面（<em>比如页面刷新就是这种场景</em>）</p></li>
</ul>
</blockquote>

<ul>
<li>查询实体动作 actions.entity-find
这里页面渲染时只有一个界面动作：查询实体（entity-find）。</li>
</ul>


<blockquote><ul>
<li><p>  通常使用<em>entity-find</em>元素（或者调用Java API使用<em>EntityFind</em>对象）时，你需要指定过滤条件，排序字段或者其他查询相关的信息去运行</p></li>
<li><p>  在这个例子中，我们使用了XML表单内的标准参数去进行实体查询，所以我们可以使用<em>search-form-inputs</em>子元素去自动生成处理字段</p></li>
<li><p>  如果想知道这些参数应该长啥样只要查看浏览器中的HTML代码即可，这些都是基于XML表单定义自动生成的</p></li>
</ul>
</blockquote>

<ul>
<li>widgets.form-list
这个例子里面定义的是个真实的表单，指定的是多条记录/行数据的“列表”表单（相对于“单个”表单）</li>
</ul>


<blockquote><ul>
<li><p>  这里的name属性可以为任意值，但是需要XML界面内唯一</p></li>
<li><p>  注意这里的list属性参照的是动作actions块中的entity-find返回的结果，transition属性参照的是界面定义最上面的transition元素</p></li>
<li><p>  既然目标是自动创建一个基于实体定义的表单，我们便给<em>auto-fields-entity</em>元素赋值为我们的&#8221;Tutorial&#8221;实体，设置field-type属性的值为&#8221;find-display&#8221;选项，表示会创建查询字段在头部并且在表格中生成并显示每条记录。</p></li>
</ul>
</blockquote>

<p>使用URL路径：<a href="http://localhost:8080/apps/tutorial/FindTutorial">http://localhost:8080/apps/tutorial/FindTutorial</a> 进行访问。</p>

<h3>指定字段</h3>

<p>如果不是按照默认的方式去生成description字段，你如何按需指定它的展现方式呢？</p>

<p>要达到这个要求，你只要在form-list元素内添加一个field元素，并且跟在fields-entity元素之后，像这样：</p>

<figure class='code'><figcaption><span>自定义指定字段</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;form-list</span> <span class="na">name=</span><span class="s">&quot;ListTutorials&quot;</span> <span class="na">list=</span><span class="s">&quot;tutorialList&quot;</span>
</span><span class='line'>        <span class="na">transition=</span><span class="s">&quot;findTutorial&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;auto-fields-entity</span> <span class="na">entity-name=</span><span class="s">&quot;Tutorial&quot;</span> <span class="na">field-type=</span><span class="s">&quot;find-display&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;field</span> <span class="na">name=</span><span class="s">&quot;description&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;header-field</span> <span class="na">show-order-by=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>          <span class="nt">&lt;text-find</span> <span class="na">hide-options=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/header-field&gt;</span>
</span><span class='line'>      <span class="nt">&lt;default-field&gt;</span>
</span><span class='line'>          <span class="nt">&lt;display/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/default-field&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/field&gt;</span>
</span><span class='line'><span class="nt">&lt;/form-list&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于此处在field元素中name属性的值对应的字段在<strong>auto-fields-entity</strong>元素执行时已被创建了，那么这里将会被重写。如果name值不在实体定义中，则会新生成一个额外的字段。这个结果看起来和<em>auto-fields-entit</em>y元素自动处理的机制很像，并且这也是你需要清晰明白的。</p>

<h3>添加一个新建表单</h3>

<p>让我们添加一个按钮来弹出一个新建表单，并创建一个转换来处理输入数据操作。</p>

<p>首先在之前创建的界面FindTutorial.xml中添加一个转换，就跟在findTutorial转换之后：</p>

<figure class='code'><figcaption><span>新建操作的转换定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;transition</span> <span class="na">name=</span><span class="s">&quot;createTutorial&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;service-call</span> <span class="na">name=</span><span class="s">&quot;create#Tutorial&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;default-response</span> <span class="na">url=</span><span class="s">&quot;.&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/transition&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个转换只是调用了<code>create#Tutorial</code>服务，然后跳转回了当前界面。</p>

<p>这个<code>create#Tutorial</code>服务从哪里来的呢？我们还没定义任何它的实现内容。Moqui框架的服务门面支持一种特殊的无需定义实现的实体增删改查（CrUD）操作的服务。这个服务的名字由两部分组成：<strong>一个动词和一个名词，中间用#隔开</strong>。只要动词为<strong><code>create, update, store, 或者delete</code></strong>，同时名词是一个有效的实体名称，服务门面就会认为这个服务是个隐式的自动实体服务并会完成预期的操作。这个服务调用是完全基于实体定义和传递的参数。举个例子，如果你使用create动词并传递实体的一个主键字段，服务就会使用这个主键字段，否则服务将会使用实体名称作为序列关键字自动生成主键序列号。</p>

<p>然后我们来添加一个新增表单，当按钮点击时展现一个隐藏的容器界面。在之前创建的FindTutorial界面中，添加容器到widget元素内的form-list元素上面，这样就会在列表表单上展现这个容器：</p>

<figure class='code'><figcaption><span>新建界面的表单定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;container-dialog</span> <span class="na">id=</span><span class="s">&quot;CreateTutorialDialog&quot;</span> <span class="na">button-text=</span><span class="s">&quot;Create Tutorial&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;form-single</span> <span class="na">name=</span><span class="s">&quot;CreateTutorial&quot;</span> <span class="na">transition=</span><span class="s">&quot;createTutorial&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;auto-fields-entity</span> <span class="na">entity-name=</span><span class="s">&quot;Tutorial&quot;</span> <span class="na">field-type=</span><span class="s">&quot;edit&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;field</span> <span class="na">name=</span><span class="s">&quot;submitButton&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>          <span class="nt">&lt;default-field</span> <span class="na">title=</span><span class="s">&quot;Create&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>          <span class="nt">&lt;submit/&gt;</span>
</span><span class='line'>          <span class="nt">&lt;/default-field&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/field&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/form-single&gt;</span>
</span><span class='line'><span class="nt">&lt;/container-dialog&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个界面定义通过刚才添加的transition来引用，并且使用<em>auto-fields-entity</em>元素中值为&#8221;edit&#8221;的<code>field-type</code>元素定义来自动生成编辑字段。最后一个小细节是声明一个按钮去提交表单，这样就可以运行了。尝试着做一下，然后看看列表中的数据是否出现新增的记录。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创译文】创建你的第一个组件（1） ]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/03/moquichap8/"/>
    <updated>2014-06-03T09:59:13+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/03/moquichap8</id>
    <content type="html"><![CDATA[<h2>概要</h2>

<p>本章是篇教你一步步创建并运行你自己的Moqui组件的向导，包含了人机交互界面，业务逻辑以及数据库交互。</p>

<ul>
<li><p>第一步：以创建一个“Hello world！”的界面开始你的第一个组件</p></li>
<li><p>第二步：延续上步，你将会定义一个自己的实体（数据库表），然后添加表单去查询和创建实体的记录</p></li>
<li><p>第三步：创建一些自定义的业务逻辑，而不使用框架自带的默认基于实体定义的CrUD逻辑操作</p></li>
</ul>


<!--more-->


<p>本文描述的运行方式就是简单的使用内嵌的servlet容器。</p>

<h2>第一步</h2>

<h3>下载Moqui框架</h3>

<p>如果你还没下载Moqui框架就赶快去下载吧。你需要有一个moqui-&lt;版本号>的目录，用来存放最新版本的moqui的war文件以及默认的运行时目录。然后以这个目录为根目录开始我们的教程。</p>

<p>如果你是新下载的，快速的初始化数据并运行吧：</p>

<blockquote><p><strong>$ ant load</strong></p>

<p><strong>$ ant run</strong></p></blockquote>

<p>使用浏览器访问 <a href="http://localhost:8080/">http://localhost:8080/</a> ，点击界面左下方名称为“John Doe”的按钮登录，然后随便看一下演示环境。
现在退出系统（命令行界面按快捷键<strong><code>&lt;ctrl-c&gt;</code></strong>），你已经可以继续下一个步骤了。</p>

<h3>创建一个组件</h3>

<p>Moqui依照“<strong><code>约定/配置优于编码</code></strong>”的原则进行组件开发，所以创建组件你所要做的就是创建目录：</p>

<blockquote><p>$ cd runtime/component</p>

<p>$ mkdir tutorial</p></blockquote>

<p>然后进入这个目录并创建一些后面要用到的标准目录：</p>

<blockquote><p>$ cd tutorial</p>

<p>$ mkdir data</p>

<p>$ mkdir entity</p>

<p>$ mkdir screen</p>

<p>$ mkdir script</p>

<p>$ mkdir service</p></blockquote>

<p>组件创建好了就启动框架吧（使用“<strong><code>$ ant run</code></strong>”或者其他类似的命令）。</p>

<h3>添加一个界面</h3>

<p>使用你常用的IDE或者文本编辑器添加一个界面的XML文件，存放于：</p>

<p><em><code>runtime/component/tutorial/screen/tutorial.xml</code></em></p>

<p>现在，制作个超简单的界面，上面只有“&#8221;Hello world!”的文本。XML内容如下：</p>

<figure class='code'><figcaption><span>Hello world界面定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;screen</span> <span class="na">require-authentication=</span><span class="s">&quot;false&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;widgets&gt;</span>
</span><span class='line'>      <span class="nt">&lt;label</span> <span class="na">type=</span><span class="s">&quot;h1&quot;</span> <span class="na">text=</span><span class="s">&quot;Hello world!&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/widgets&gt;</span>
</span><span class='line'><span class="nt">&lt;/screen&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意上面的<code>require-authentication</code>属性被设置为false。默认的值为true，并且这个界面会被要求授权和鉴权。我们会在后面的安全的章节中讨论可配置的自动识别的构件授权机制。</p>

<h3>以子界面方式挂载</h3>

<p>为了能让你的界面访问生效，需要将这个界面作为子界面挂载到根界面下某个已存在的界面下。在Moqui框架的界面机制中，访问界面的URL路径以及功能菜单的结构都是基于子界面的层级进行驱动的，所以这种挂载方式将会自动设置这个界面的访问URL路径并添加一个菜单分页。</p>

<p>因为这个入门例子的目标，我们将使用已有的根界面以及运行时目录中界面的头部、尾部等资源。运行时目录中有一个定义了根界面的webroot组件位于：</p>

<p><em><code>runtime/component/webroot/screen/webroot.xml</code></em></p>

<p>顺便说下，根界面在Moqui的XML配置文件中通过<code>webapp-list.webapp.root-screen</code>元素被指定，你可以为不同的域名配置多个入口的根界面。</p>

<p>为了使子界面层级定义的方式更灵活，入口根界面只有一个基础的HTML头和body，没有头部和尾部的页面内容，所以我们把我们的界面放到“apps”界面下，“apps”界面中已有一个头部的菜单并提供了一些内容。修改apps的界面：</p>

<p><em><code>runtime/component/webroot/screen/webroot/apps.xml</code></em></p>

<p>apps.xml文件中，在subscreens元素下添加一个subscreens-item元素，如下：</p>

<figure class='code'><figcaption><span>子界面定义1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;subscreens-item</span> <span class="na">name=</span><span class="s">&quot;tutorial&quot;</span> <span class="na">menu-title=</span><span class="s">&quot;Tutorial&quot;</span>
</span><span class='line'>              <span class="na">location=</span><span class="s">&quot;component://tutorial/screen/tutorial.xml&quot;</span><span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>名称（name）属性用于指定URL访问这个页面的路径值，所以你的界面在浏览器上的访问路径为：<a href="http://localhost:8080/apps/tutorial">http://localhost:8080/apps/tutorial</a></p>

<p>如果你不想修改已存在的界面文件，但是仍然希望将你的界面作为子界面挂载到其他界面下，你可以通过数据库记录的方式去达到这个目的。类似于（在<code>entity-facade-xml</code>中格式化代表实体的元素以及代表字段的元素）：</p>

<figure class='code'><figcaption><span>子界面定义2</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;SubscreensItem</span> <span class="na">screenLocation=</span><span class="s">“component://webroot/screen/webroot/apps.xml”</span>
</span><span class='line'>              <span class="na">subscreenName=</span><span class="s">&quot;tutorial&quot;</span> <span class="na">userGroupId=</span><span class="s">“ALL_USERS&quot;</span>
</span><span class='line'>              <span class="na">subscreenLocation=</span><span class="s">“component://tutorial/screen/tutorial.xml&quot;</span>
</span><span class='line'>              <span class="na">menuTitle=</span><span class="s">&quot;Tutorial&quot;</span> <span class="na">menuIndex=</span><span class="s">&quot;1&quot;</span> <span class="na">menuInclude=</span><span class="s">&quot;Y&quot;</span><span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>初试界面内嵌入内容</h3>

<p>除了使用label节点元素，我们还可以在界面“下”使用HTML文件的方式。首先新建一个简单的HTML文件，放在：<em><code>runtime/component/tutorial/screen/tutorial/hello.html</code></em></p>

<p>这个HTML文件能包含任何的HTML元素，同时既然界面的父界面又包含了头部/尾部等，这个HTML文件又被包含在这个界面中，我们就可以很简单的这样处理这个HTML了：</p>

<figure class='code'><figcaption><span>HTML页面</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;h1&gt;</span>Hello world! (from hello.html file)<span class="nt">&lt;/h1&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在就可以在tutorial.xml界面定义中使用<code>render-mode.text</code>元素来明确包含这个HTML文件了：</p>

<figure class='code'><figcaption><span>界面中嵌入HTML</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;screen&gt;</span>
</span><span class='line'>    <span class="nt">&lt;widgets&gt;</span>
</span><span class='line'>        <span class="nt">&lt;label</span> <span class="na">type=</span><span class="s">&quot;h1&quot;</span> <span class="na">text=</span><span class="s">&quot;Hello world!&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;render-mode&gt;</span>
</span><span class='line'>            <span class="nt">&lt;text</span> <span class="na">type=</span><span class="s">&quot;html&quot;</span>
</span><span class='line'>            <span class="na">location=</span><span class="s">&quot;component://tutorial/screen/tutorial/hello.html&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/render-mode&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/widgets&gt;</span>
</span><span class='line'><span class="nt">&lt;/screen&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么这个render-mode到底是什么东西？Moqui框架的XML界面理念中存有<strong><code>平台不可知论</code></strong>以及界面可被渲染在各种环境中。源于此，我们不想界面内的任何东西在没有明确清楚的情况下就以某种确定渲染方式去展现。在render-mode下，你可以为不同的渲染模式定义各种子元素，甚至是各种文本模式，如HTML，XML，XSL-FO（<em>用于格式化XML数据的语言，全称为Extensible Stylesheet Language Formatting Objects 格式化对象的可扩展样式表语言，是W3C参考标准，现在通常叫做XSL</em>），CSV等。这样的话，一个界面定义就可以被渲染成不同的模式，并且输出的产品也可以按需进行切换。
这个界面还是按照前面例子的URL路径去访问，只是现在采用的是嵌入HTML页面内容的方式，而不是在界面定义中内联使用一个label元素的方式了。</p>

<h4>再试界面子内容方式</h4>

<p>另外种方式展现这个hello.html的内容就是把它作为界面的子内容。</p>

<p>这样的话，这个hello.html文件必须被放置在与这个界面同名的子目录下。例如，放在tutorial.xml文件同级的一个名为tutorial的文件夹下。</p>

<p>现在我们还需要做到如下几点：</p>

<ul>
<li>设置界面的<code>include-child-content</code>属性为“true”，用来声明tutorial.xml界面包含了子内容</li>
<li>添加<code>widgets</code>下的<code>subscreens-active</code>元素，用以确定界面包含子界面或者子内容的位置</li>
</ul>


<p>完成上述操作，你的界面的XML文件应该如下所示：</p>

<figure class='code'><figcaption><span>界面中嵌入HTML</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;screen</span> <span class="na">include-child-content=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;widgets&gt;</span>
</span><span class='line'>      <span class="nt">&lt;label</span> <span class="na">type=</span><span class="s">&quot;h1&quot;</span> <span class="na">text=</span><span class="s">&quot;Hello world!&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;subscreens-active/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/widgets&gt;</span>
</span><span class='line'><span class="nt">&lt;/screen&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了能看到这个文件内容，你需要访问另外个URL路径来知会Moqui框架你需要获得tutorial界面下的hello.html文件：<a href="http://localhost:8080/apps/tutorial/hello.html">http://localhost:8080/apps/tutorial/hello.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创译文】运行Moqui  ]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/03/moquichap7/"/>
    <updated>2014-06-03T09:55:21+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/03/moquichap7</id>
    <content type="html"><![CDATA[<h2>下载Moqui以及必备软件</h2>

<p>Moqui框架默认的配置软件只需要Java的JDK 6及以后版本（推荐JDK 7）。源码构建编译框架需要Gradle 1.6及以后版本。</p>

<p>你可以从SourceForge下载Moqui框架：</p>

<p><a href="https://sourceforge.net/projects/moqui/files/">https://sourceforge.net/projects/moqui/files/</a></p>

<!--more-->


<p>选择最新版本的目录，然后任意选择二进制或者源码发布包。框架的二进制发布包以“moqui-&lt;版本号>.zip”命名，源码包以“moqui-&lt;版本号>-src.zip”命名。</p>

<p>Moqui框架的最新源码可以通过GitHub进行下载和在线预览，地址为：</p>

<p><a href="https://github.com/jonesde/moqui" title="moqui源码">https://github.com/jonesde/moqui</a></p>

<p>同样的业务地幔构件的GitHub最新代码地址为：</p>

<p><a href="https://github.com/jonesde/mantle" title="mantle源码">https://github.com/jonesde/mantle</a></p>

<p>虽然你可以单独的从GitHub上下载Mantle 地幔构件，但是在SourceForge上也有一个内嵌Moqui框架环境的Mantle整包。</p>

<h2>运行时目录以及Moqui的XML配置文件</h2>

<p>Moqui框架部署运行主要有三个核心部分：</p>

<blockquote><ul>
<li>可执行的WAR包文件（详细见下）</li>
<li>运行时目录</li>
<li>Moqui配置文件（XML格式）</li>
</ul>
</blockquote>

<p>不管你怎么使用这个可执行的WAR文件，你必须拥有一个运行时的目录，同时你也许会重写Moqui默认配置文件（<em><code>MoquiDefaultConf.xml</code></em>文件）里的配置信息，例如在运行时目录或者conf目录中的<em><code>MoquiProductionConf.xml</code></em>文件里面重写。</p>

<p>运行时目录主要放置的是你想要加载的组件、应用系统的入口文件（界面入口文件）以及配置文件。同时，框架会在这个目录下存放日志文件，Derby 数据库文件（如果你使用Derby数据库的话）等。也许你最终是要在自己的代码库里面创建自己的运行时目录，你可以把默认的运行时目录作为你的工程的起始点。
运行的时候，需要指定下如下两个属性：</p>

<table>
<thead>
<tr>
<th>属性</th>
<th>属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><em><strong> moqui.runtime </strong></em> </td>
<td>指定运行时目录（如果存在runtime的子目录，默认配置为“./runtime”;如果不存在，则配置为“.”）</td>
</tr>
<tr>
<td><em><strong> moqui.conf </strong></em> </td>
<td>指定Moqui的运行时配置文件（类似上面配置，使用URL或者路径方式配置）</td>
</tr>
</tbody>
</table>


<p>这里有两种方式去指定这两个属性：</p>

<blockquote><ul>
<li>通过编译路径下的<em><code> MoquiInit.properties</code></em> 文件</li>
<li>在命令行通过系统属性去指定（使用java -D 参数）</li>
</ul>
</blockquote>

<h2>可执行的WAR文件</h2>

<p>耶，是的：就是一个可以执行的WAR文件。你主要做的就是下面这些事情（通过简单的命令去按需展示和修改）：</p>

<table>
<thead>
<tr>
<th></th>
<th>命令说明        </th>
<th align="center">命令示例</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><em><strong>加载数据</strong></em> </td>
<td align="center">$ java -jar moqui-&lt;version>.war -load</td>
</tr>
<tr>
<td></td>
<td><em><strong>运行内置的web服务</strong></em> </td>
<td align="center">$ java -jar moqui-&lt;version>.war</td>
</tr>
<tr>
<td></td>
<td><em><strong> WAR包形式部署（Tomcat等）</strong></em> </td>
<td align="center">$ cp moqui-&lt;version>.war ../tomcat/webapps</td>
</tr>
<tr>
<td></td>
<td><em><strong> 显示配置和帮助信息）</strong></em> </td>
<td align="center">$ java -jar moqui-&lt;version>.war -help</td>
</tr>
</tbody>
</table>


<p>当运行数据加载器时（使用 -load 参数），以下的附加参数都是可用的：</p>

<table>
<thead>
<tr>
<th></th>
<th> 附加参数             </th>
<th align="center"> 使用说明           </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> <em><strong>-types=&lt;type>[,&lt;type>]</strong></em></td>
<td align="center"> 加载指定的数据类型，适配entity-facade-xml.@type属性（可以是任意的数据，通常为：种子数据，种子初始化数据，样例数据等）</td>
</tr>
<tr>
<td></td>
<td> <em><strong>-location=&lt;location> </strong></em> </td>
<td align="center"> 加载指定路径下的单个数据文件  </td>
</tr>
<tr>
<td></td>
<td> <em><strong>-timeout=&lt;seconds> </strong></em> </td>
<td align="center"> 每个文件加载事务的超时时间，默认为600秒（10分钟）</td>
</tr>
<tr>
<td></td>
<td> <em><strong>-dummy-fks </strong></em>    </td>
<td align="center"> 使用虚拟外键，规避引用完整性错误</td>
</tr>
<tr>
<td></td>
<td> <em><strong>-use-try-insert </strong></em> </td>
<td align="center"> 尝试插入、更新操作来替代优先检查数据记录的异常校验</td>
</tr>
<tr>
<td></td>
<td> <em><strong>-tenantId=&lt;tenantId> </strong></em> </td>
<td align="center"> 加载指定租户ID的数据</td>
</tr>
</tbody>
</table>


<p>注意下，如果命令中没有<em>-types</em> 或者 <em>-location</em> 参数，将会加载所有已知类型的数据文件。</p>

<p>上面显示的运行时配置moqui.runtime 和moqui.conf 属性的例子来源于编译路径下的MoquiInit.properties文件。通过命令行来指定这些参数的例子如下：</p>

<p><code>$ java –D moqui.conf=conf/MoquiStagingConf.xml -jar moqui-&lt;version&gt;.war</code></p>

<p>注意：moqui.conf参数的路径关联的是moqui.runtime的目录，或者换句话说，指定的是相应运行时目录下的配置文件。</p>

<p>当运行内嵌的web服务（除了使用<em>-load</em>和<em>-help</em>参数）使用的是Winstone Servlet容器。完整的Winstone可用参数列表，请参见：</p>

<p><a href="http://winstone.sourceforge.net/#commandLine">http://winstone.sourceforge.net/#commandLine</a></p>

<p>为了方便使用，此处罗列下常用的Winstone参数：</p>

<table>
<thead>
<tr>
<th></th>
<th> 参数             </th>
<th align="center"> 参数说明           </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> <em><strong> &mdash;httpPort</strong></em> </td>
<td align="center"> 设置http的监听端口。-1表示禁用，默认为8080</td>
</tr>
<tr>
<td></td>
<td> <em><strong> &mdash;httpListenAddress </strong></em> </td>
<td align="center"> 设置http的监听地址。默认为所有接口</td>
</tr>
<tr>
<td></td>
<td> <em><strong> &mdash;httpsPort </strong></em> </td>
<td align="center"> 设置https的监听端口。-1表示禁用，默认禁用</td>
</tr>
<tr>
<td></td>
<td> <em><strong> &mdash;ajp13Port </strong></em> </td>
<td align="center"> 设置ajp13的监听端口。-1表示禁用，默认为8009</td>
</tr>
<tr>
<td></td>
<td> <em><strong> &mdash;controlPort </strong></em> </td>
<td align="center"> 设置关闭/控制的端口。-1表示禁用，默认禁用</td>
</tr>
</tbody>
</table>


<h2>在WAR文件中内嵌运行时目录</h2>

<p>Moqui框架能够运行加载一个外部的运行时目录（独立于WAR文件之外），也支持运行时目录打包在WAR文件内部的方式。内嵌的方式特别适用于类似Amazon ElasticBeanstalk这种WAR部署方式的容器。创建一个内嵌运行时目录的WAR文件步骤如下：</p>

<blockquote><ol>
<li>  在运行时目录下添加必须的组件以及其他的资源文件</li>
<li>  按照需要调整 <code>${moqui.home}/MoquiInit.properties</code> 文件</li>
<li>  必要时调整Moqui的配置文件（<code>runtime/conf/Moqui*Conf.xml</code>）</li>
<li>  基于moqui.war文件、你的运行时目录的所有文件以及<code>MoquiInit.properties</code>配置文件，打一个完整WAR包的方式为以下任意一种：</li>
</ol>


<blockquote><ul>
<li><p><code>$ gradle addRuntime</code></p></li>
<li><p><code>$ ant add-runtime</code></p></li>
</ul>
</blockquote>

<ol>
<li>  拷贝创建好的WAR文件（<code>moqui-plus-runtime.war</code>）到部署的目标位置</li>
<li>  运行服务（或者重启/刷新去自动更新运行的WAR）</li>
</ol>
</blockquote>

<p>最终的WAR文件的根目录下就是运行时目录（和WEB-INF目录同级），并且所有的JAR文件都在WEB-INF/lib 目录下。</p>

<h2>编译Moqui框架</h2>

<p>Moqui框架使用Gradle去编译源码。虽然有各种用户自定义的能自动处理常用的构建任务，但是最常用的还是Gradle自带的构建编译任务。框架内部还有一个Ant的构建编译文件，但是这个文件内只是一些常用任务，不包含编译源码的任务。</p>

<table>
<thead>
<tr>
<th></th>
<th>任务说明        </th>
<th align="center">Gradle命令        </th>
<th align="center">Ant命令</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><em><strong> 编译JAR，WAR文件</strong></em> </td>
<td align="center"> $ gradle build </td>
<td align="center">   </td>
</tr>
<tr>
<td></td>
<td><em><strong> 加载所有的数据</strong></em> </td>
<td align="center"> $ gradle load </td>
<td align="center"> $ ant load</td>
</tr>
<tr>
<td></td>
<td><em><strong> 运行WAR内的服务</strong></em> </td>
<td align="center"> $ gradle run </td>
<td align="center"> $ ant run</td>
</tr>
<tr>
<td></td>
<td><em><strong> 清除JAR，WAR文件</strong></em> </td>
<td align="center"> $ gradle clean </td>
<td align="center">  </td>
</tr>
<tr>
<td></td>
<td><em><strong> 清空所有的编译文件和运行时创建的文件（日志、数据库文件等）</strong></em> </td>
<td align="center"> $ gradle cleanAll </td>
<td align="center">  </td>
</tr>
</tbody>
</table>


<p>注意在Gradle里面，加载（load）和运行（run）任务都依赖于构建（build）任务。由于这种依赖存在，最简单的方式去在一个流行的数据库上创建一个新的开发环境可以通过执行这个命令： <em><code>$ gradle load run</code></em>
它将会创建war文件，运行数据加载器，然后启动服务。停止服务只需要键入<strong><code>&lt;ctrl-c&gt;</code></strong>（或者你自定义的快捷方式）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创译文】Moqui 概览 — 纵览 ]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/03/moquichap6/"/>
    <updated>2014-06-03T09:55:16+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/03/moquichap6</id>
    <content type="html"><![CDATA[<h2>Web浏览器请求</h2>

<p>一个web浏览器请求经由Servlet容器会传递到框架层面（默认实现是内嵌了Winstone Servlet容器，同样也支持Tomcat以及其他的Java Servlet规范容器）。Servlet容器通过web.xml文件按照标准的方式在服务器上找到安装的MoquiServlet，并查找到相应的请求路径。MoquiServlet很简单，仅仅设置了一个运行时上下文，然后渲染请求的界面。</p>

<!--more-->


<p>Web应用的界面渲染源自于配置的“根”界面，然后希望获取到的目标界面都通过子界面路径的方式向下查找。除了目标界面路径，可能也同时会有一个转换名称用于跳转到目标界面。</p>

<p>转换用于处理界面跳转的输入数据（而不是准备展现的数据），区别于界面上的动作，动作通常是为了准备呈现的数据（不是处理跳转的输入数据）。如果存在一个转换名称，那么这个转换对应的服务和动作就会运行，同时会反馈一个转换指定的响应（基于条件约定而不管是否存在错误），然后通常这个响应会在跳转到另一个界面进行反馈。</p>

<p>当一个服务被调用（通常来源于转换或者界面动作），服务门面会按照服务定义去验证并清空输入的map，然后调用执行定义好的内部或者外部脚本，Java方法，自动或隐式的实体操作或者远程服务。</p>

<p>与数据库交互的实体操作，只能通过服务进行写操作，同时任何时候都可以通过界面的动作去进行读操作（转换、界面动作、服务脚本/方法等都可以支持读操作）。</p>

<p><img src="http://gagaboy.github.io/moquiImgs/requestProcess.png" title="requestProcess" alt="requestProcess" /></p>

<h2>Web服务调用</h2>

<p>Web服务请求通常伴随着一个浏览器端的表单提交请求发起，并受控于界面跳转。请求过来的数据受控于跳转的动作，同时，action动作控制的响应比较特殊，需要以XML，JSON等格式进行返回。跳转/转换的默认响应需要被设置为“none”类型，这样就不会去请求渲染界面或者重定向到某个界面了。</p>

<h2>邮件的接收、发送</h2>

<p>接收邮件通过pollEmailServer服务（配置使用email邮件服务的实体）进行邮件的ECA规则来控制。这些规则里含有解析邮件以及格式化成有效的maps格式的信息。如果规则条件满足，就会执行规则定义的动作行为。规则能够支持你想要做的任何事情，比如在某些地方保存某些信息，在目录中添加一个用于回顾的队列，生成一个自动触发的响应等。</p>

<p>发送邮件最简单的方式就是调用sendEmailTemplate服务。这个服务通过emailTemplateId查找到EmailTemplate记录，就能获取到这个待发送邮件的配置信息，包括标题、发送地址、要展示的XML界面、附件等各种其他操作。这意味着可以适用于各种邮件场景，特别是通知公告类的信息，以及系统管理的自动回复客户的服务信息等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创译文】Moqui 概览 — 基本概念（3）]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/03/moquichap5/"/>
    <updated>2014-06-03T09:55:00+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/03/moquichap5</id>
    <content type="html"><![CDATA[<h2>开发过程</h2>

<p>Moqui开发框架为了促进开发实现，采用了一些自然的概念，映射源自于设计阶段的元素，比如：界面概览和线框，页面流图，数据声明以及自动的业务过程描述。这里的每个设计阶段的构件都能够被转化为Moqui工具集中特定的实现构件。</p>

<!--more-->


<p>这种设计的构件通常是最好的，特别是在基于明确定义和组织特定的活动，例如必须支持干系人和系统之间互相影响之类的需求上。这些需求应当是清晰的，并且能按照设计进行分解以便辅助驱动设计的决策，同时，必须确保系统中所有关键的方面都被认真考虑到并能覆盖设计。</p>

<p>通过这种方式，实现构件能够引用设计的内容，顺延的，设计能够引用需求的内容。伴随着自然的映射设计时的构件，就能很简单的去开发实现业务构件并能同时分配和验证它们。</p>

<p>按照这种架构设计去实现构件的话，通常首先要求创建构件的这个顺序就无关紧要了。不同的人员甚至可以并行的去工作，比如定义实体和创作界面。</p>

<p>对于基于web的应用系统来说，特别是那些需要个性化艺术设计的公开应用，静态构件类似如图片或者CSS样式等都需要独立于界面XML，以单独的文件进行存储。同时，这些静态构件需要按照子界面的目录结构规范去组织文件结构，并且最外层目录需要与界面名相同。在子界面的层级下，不同界面的资源很自然的可以共享。</p>

<p>真实按照界面和表单XML生成的HTML页面能够被个性化定制，只需要对应每个XML元素的生成输出去重写或者添加FreeMarker的宏定义即可。当有需要时，个性化的HTML页面也是可以被包含到界面中的。框架允许这种半可视化的方式定制生成带样式和脚本的HTML页面，或者需要时直接通过自定义的HTML页面去满足需求。</p>

<p>Web前端设计师能够查看真实的通过独立的CSS或者其他静态资源自动生成的HTML页面进行前端开发工作。当需要个性化定制时，前端开发人员可以先制作出HTML原型页面，然后开发人员可以通过制作模板或者定制参数匹配宏定义将定制部分融入到系统中。</p>

<p>另外一种比较好的做法是，雇佣较多的高级前端工程师去完成整个系统的客制化前端HTML、样式及脚本等，前端使用某个格式的JSON数据通过HTTP协议与后端的服务接口进行交互<em><code>（注：这也是较流行的单页面或者RESTful风格的架构）</code></em>。这种方式也比较适合于手机或者桌面终端应用通过web services与服务器端进行交互。Web services你可以使用框架内置的JSON-RPC、XML-RPC或者其他的服务自动映射工具，也可以使用自定义的包装服务去调用内部的服务以支持各种web服务应用架构。</p>

<p>不管怎样，对于一个给定的项目来说，你的团队应该是有分工的，各管一块。框架允许你将一个项目按照设计分割成多个构件，这样就很容易的去分配工作了，大家也可以很方便的在定义好的接口基础上并行进行开发工作。</p>

<h2>开发工具</h2>

<p>在需求和设计阶段，你需要一组很好用的工具来方便用户、领域专家、需求分析人员、设计人员以及开发人员进行沟通交流。这些工具应当具有以下特性：</p>

<blockquote><ul>
<li>层次化的文档结构</li>
<li>文档间或者文档内有链接可以关联（通常是链接显示的是被关联的文档标题）</li>
<li>文档需要支持图片等附件形式</li>
<li>每个文档需要有完整的修订版本历史记录</li>
<li>每个文档需要有线框的评论内容</li>
<li>文档更新能够自动邮件通知</li>
<li>统一库管理，能够在线访问，便于交流</li>
</ul>
</blockquote>

<p>现实中有很多这类的工具可供选择，但是大部分的都不满足上述所有的要求，所以沟通上因此会产生诸多不便。一个很好的商业化的选择是<strong><em>Atlassian</em></strong>公司的<strong>Conﬂuence</strong>。相对很多面向大规模组织使用的产品，<strong><em>Atlassian</em></strong>提供了一种小团队能够负担的起的本地部署方案。同样开源里面也有很多的选择，包括基于Moqui和Mantle的wiki就用在了HiveMind的项目管理上。</p>

<p>注意下，内容沟通工具通常会与你的代码库隔离，尽管如果你把内容管理工具和你的代码库合并，那么参与你的项目的人会比较方便的使用它。因为Moqui框架本身支持渲染wiki页面和传递二进制的附件，所以你可能会认为这是个Moqui的组件。但这里最大的问题是，除非Moqui有个很完善好用的wiki应用能够很方便的更新内容，否则这将很难去吸引技术较弱的人来参与Moqui的项目。</p>

<p>对于实际的代码库也有很多的选择，但更多的会依赖于个人或者团队的倾向。Moqui本身是存放在<strong>GitHub</strong>上的，并且<strong>GitHub</strong>上的私有库的价格是能接受的（特别是些小的项目库）。如果你正好也使用<strong>GitHub</strong>，从jonesde的moqui库中切分支，在自己的私有库中维护自己的运行时目录，同时定期更新基础的主程序的代码即可。</p>

<p>对于项目开发来说，即使你不使用<strong>GitHub</strong>，那么使用一个本地或者远程的git代码库也是个很好的管理代码的方式。当然，如果你倾向于使用<em>Subversion</em>或者<em>Mercurial</em>，也是无可厚非的选择。</p>

<p>对于真正的开发过程来说，你也许需要一个编辑器或者开发环境支持以下类型的文件：</p>

<blockquote><ul>
<li><strong><em><code>XML</code></em></strong>（支持自动完成、验证、显示注释等）</li>
<li><strong><em><code>Groovy</code></em></strong>（groovy脚本语法特性支持以及XML文件中的groovy脚本语法特性支持）</li>
<li><strong><em><code>HTML，CSS和JavaScript脚本</code></em></strong></li>
<li><strong><em><code>FreeMarker</code></em></strong>（FTL）</li>
<li><strong><em><code>Java</code></em></strong>（可选的）</li>
</ul>
</blockquote>

<p>我个人倾向使用的是<strong><em>JetBrains</em></strong>的IDE工具<strong>IntelliJ IDEA</strong>。社区免费版对于XML和Groovy支持性非常好。对于HTML，CSS，JavaScript以及FreeMarker支持你需要购买商业版，否则IDE只是作为简单文本编辑器支持。我就是使用了商业版完成了大部分Moqui框架的实现，包括复杂的FreeMarker宏定义模板。在购买了个人授权使用商业版后，我开发起来真的很爽，但是社区版本身就已经很强大了。</p>

<p>其他流行的Java IDE比如<strong><em>Eclipse</em></strong> 和<em><strong>NetBeans</strong></em>同样也是很好的开发选择，它们提供了构建和插件功能去支持以上这些类型的文件。我个人喜欢开发工具有自动完成和其他高级的开发辅助功能，但是你如果喜欢简单的文本编辑器，那么选择自己喜欢的就好了。</p>

<p>Moqui 开发框架基于Gradle（1.0及以上版本）构建。虽然包括<strong>IntelliJ IDEA</strong>在内的IDE都提供了相当好的简化命令任务的用户界面操作支持，但是我个人更喜欢命令行的方式去构建运行项目。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创译文】Moqui 概览 — 基本概念（2）]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/03/moquichap4/"/>
    <updated>2014-06-03T09:47:10+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/03/moquichap4</id>
    <content type="html"><![CDATA[<h2>运行时上下文<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2>

<p>运行时上下文是Moqui API的应用核心接口部分。运行时会独立的创建一个上下文实例去执行边缘的构件，如界面或者服务。运行时上下文，或者简写为“ec”，拥有各种门面的接口去曝露各种框架的功能和工具。</p>

<!--more-->


<p>上下文同时也维护着一个上下文的map用来呈现每个构件运行的可变空间。这个上下文map是一个map的堆栈，每个构件执行在一个干净的map中，并入栈，一旦构件结束运行即出栈。每当读取这个map栈都将从头开始向下遍历直到找到符合条件的map条目。当写这个map栈时，总是在栈的顶部去执行写操作（除非明确的指定参照根map，例如在栈底的map）。</p>

<p>通过这种方式，每个构件无需担心其他构件的影响，但是构件仍然具有很容易的去访问父构件的数据（通过调用构件链的方式调用或者包含方式，能够向下找到当前的构件）。由于上下文是为了每个边缘构件的执行去创建的，所有它拥有构件运行的详实信息，如：什么时候启用，包含的用户，构件携带的信息等等。</p>

<h2>构件栈<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h2>

<p>每个构件在运行时或者包含、调用其他构件时，这个构件都会即时的被压入栈中。这个栈始终维持着当前活动的构件的轨迹，同时构件的执行信息也会被添加到一个构件使用情况的追踪历史列表中。</p>

<p>当构件入栈时，每个构件都需要进行鉴权，同时构件关联的安全信息也会被追溯记录。通过这种方式，权限设计就变得很简单了，包含的构件、被调用的构件都能够继承相应的权限。这种权限继承的机制带来的好处是你只需配置并控制直接能访问的关键界面或者服务就可以了<em><code>（注：这意味着内部调用的其他界面或者逻辑服务无需关心鉴权，会直接继承调用者的权限）</code></em>。</p>

<h2>管中窥豹，可见一斑<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h2>

<p>在使用Moqui框架进行开发时，你将会经常用到高度抽象的业务构件，如XML定义文件。这种设计方式是为了一方面支持很多通用的需求，同时另一方面也是为了能灵活的在任何点上都可以向下落到低层级的工具上，如模板、脚本等。在某些点上，你也许希望了解到框架内部到底在做什么，或者当你遇到了一个问题时，如果你明确知道框架内部的处理机制你能更容易定位处理问题。</p>

<p>然而服务和实体定义通过代码进行控制；其他的构件比如XML动作以及XML界面和表单是通过FreeMarker模板的宏定义去转换处理成其他文本方式去渲染的。XML动作（Actions）定义会被转化为简单的Groovy脚本，然后被容器编译成class文件，并进行缓存和执行。XML界面和表单中显示的部分（widget组件）同样会通过模板被转化为特定的输出类型（html，xml，xsl-fo,csv,text等等）。</p>

<p>通过这种形式，你能够很容易的看到通过模板生成的输出结果，并且通过简单的配置，你甚至可以制定你自己修改的模板或者扩展开箱即用的功能点。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The Execution Context <a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>The Artifact Stack <a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>意译：Peeking Under the Covers <a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创译文】Moqui 概览 — 基本概念（1） ]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/02/moquichap3/"/>
    <updated>2014-06-02T14:36:09+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/02/moquichap3</id>
    <content type="html"><![CDATA[<h2>应用构件/工件</h2>

<p>Moqui开发框架的工具集都是围绕着业务构件进行组织的，同时这些业务构件允许你进行创建来体现应用系统的通用部分。在Moqui框架中，业务构件指的是你作为开发人员创建的各种XML文件甚至是脚本或者其他代码。框架中支持如下的几种类型的构件：</p>

<!--more-->


<blockquote><p><strong>实体<em><code>entities</code></em></strong> ：贯穿于整个业务系统中的关系数据模型（直接使用模型，无需复杂的对象关系映射）</p>

<p><strong>界面<em><code>screens</code></em> 和 表单<em><code>forms</code></em></strong> ：用于基于web的应用界面或者其他用户接口（通用方式是基本构件描述存放在XML文件中，或者用户指定扩展存放于数据库中）</p>

<p><strong>界面转换 <em><code>screen transitions</code></em></strong> : 用于配置页面到页面的流转以及设置页面跳转时，业务处理过程的必要输入</p>

<p><strong>服务 <em><code>services</code></em></strong> : 远程调用的方式运行内部逻辑交互或者曝露外部的服务</p>

<p><strong>ECA（事件-条件-行为<em><code>event-condition-action</code></em>）规则</strong> : 用于类似实体、服务操作以及email信息接收等系统级事件触发</p></blockquote>

<p>下面给出一个表格来展示应用中通用部分以及业务构件之间的联系：</p>

<table>
<thead>
<tr>
<th>构件</th>
<th>构件描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><em><strong>界面screen</strong></em></td>
<td>XML定义的界面（渲染成各种类型的文本或者用于生成其他UI界面；支持html、xml、xsl-fo、csv以及简单文本转换，开箱即用）</td>
</tr>
<tr>
<td><em><strong>表单form</strong></em></td>
<td>XML定义的表单（在界面内定义；各种开箱即用的组件widgets，并可以自定义组件或者自定义扩展已有组件）</td>
</tr>
<tr>
<td><em><strong>准备展示的数据</strong></em></td>
<td>界面动作actions（在界面内定义，可以调用外部逻辑）</td>
</tr>
<tr>
<td><em><strong>页面流</strong></em></td>
<td>带条件定义和默认响应的界面转换（在源界面内定义转换，响应目标配置为目标界面或者外部页面资源）</td>
</tr>
<tr>
<td><em><strong>处理过程输入</strong></em></td>
<td>转换动作actions（不仅可以支持一个简单的服务处理表单的公共验证等，也可以定义页面内部的动作或者外部逻辑调用）</td>
</tr>
<tr>
<td><em><strong>菜单</strong></em></td>
<td>按照子界面的层级配置定义遍历，自动生成，也可以明确配置定义菜单</td>
</tr>
<tr>
<td><em><strong>内部服务</strong></em></td>
<td>XML的服务配置方式来定义各种内部或者外部服务操作的实现</td>
</tr>
<tr>
<td><em><strong>XML和JSON的RPC服务</strong></em></td>
<td>内部服务配置<em><code>allow-remote=true</code></em> 参数，即可以通过公共的服务接口被调用，接口使用的是规范的List和Map数据接口进行映射</td>
</tr>
<tr>
<td><em><strong>RESTful web服务</strong></em></td>
<td>通过简单的转换定义来获取内部服务，支持URL路径、表单、JSON请求以及JSON或者XML响应</td>
</tr>
<tr>
<td><em><strong>远程服务调用</strong></em></td>
<td>代理方式来定义内部服务，可以采用自动的XML-RPC、JSON-RPC或者其他的映射方式，也可以使用支持RESTful的简单工具或者其他服务类型</td>
</tr>
<tr>
<td><em><strong>发送邮件</strong></em></td>
<td>在EmailTemplate中单独配置下标题，界面能直接渲染成html、简单文本的邮件格式</td>
</tr>
<tr>
<td><em><strong>接收邮件</strong></em></td>
<td>定义一个email的ECA规则用于调用一个内部服务去处理email</td>
</tr>
<tr>
<td><em><strong>使用脚本、模板和JCR内容</strong></em></td>
<td>通过资源的门面接口去访问、执行或者渲染资源</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创译文】Moqui  概览 — 框架介绍 ]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/01/moquichap2/"/>
    <updated>2014-06-01T17:42:52+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/01/moquichap2</id>
    <content type="html"><![CDATA[<h2>什么是Moqui生态系统？</h2>

<p>Moqui生态系统是一组以一个共同的框架和一系列通用的业务构件为中心的软件包。核心的软件包（在下图中的Core内核和Mantle 地幔中）被拆分为不同的开源项目工程，这种方式可以保证维持其既定目标各自发展，并且能够关注于这些工程的管理和依赖处理，同时保持工程的清洁性。这些软件包按照适中的的社区化管理方式，就像Linux的Kernel内核一样。</p>

<!--more-->


<p><img src="http://gagaboy.github.io/images/MoquiWorld.png" title="Moqui FrameWork" alt="Moqui FrameWork" /></p>

<p>这个生态系统的目标是为了能提供一组内部可交互并且能够与商业软件竞争的构件（在Crust外壳 中提供的插件机制）。这些构件和机制都基于一个共同的框架并具有很高的客制化的灵活性和简易性，同时，系统提供的一系列通用业务构件（数据模型和逻辑服务）使得其更加完整和完备。</p>

<p>这个生态系统包含：</p>

<ul>
<li><p><strong>Moqui 框架：</strong>简易高效、安全灵活的开发支持</p></li>
<li><p><strong>地幔业务构件：</strong>一组通用普适的、可作为您各种场景业务系统的基础业务构件集合，包含：</p></li>
</ul>


<blockquote><p><strong><em>UBPL</em></strong> ：通用业务过程/流程库</p>

<p><strong><em>UDM </em></strong> ：通用的数据模型</p>

<p><strong><em>USL   </em></strong> ：通用业务服务库</p></blockquote>

<ul>
<li><strong>地壳（插件）：</strong>主题皮肤、综合的工具集、不同行业的应用支持、大公司规模支持、业务领域支持等</li>
</ul>


<p>本书的关注核心是Moqui框架，但是最后一章将对地幔业务构件进行总结。</p>

<p>=================================================================================</p>

<h2>什么是Moqui开发框架？</h2>

<p>Moqui开发框架是一个全功能的，企业级应用开发框架，基于Groovy和Java语言。这个开发框架包含了一系列的工具用于开发界面、服务、实体以及诸如声明式的构件安全、多租户支持等这种高级功能特性。</p>

<p>这个框架十分适合于开发各种简单的web应用站点（如moqui.org）以及小规模的复合ERP系统。构建于Moqui框架基础上的应用系统十分容易部署在各种高扩展性的基础软件上（例如Java Servlet容器或者应用服务器），并支持传统的关系型数据库以及很多现代的非关系型NoSQL数据库上。</p>

<p>Moqui开发框架基于Ofbiz（目前Apache的顶级项目OFBiz, 参见 <a href="http://ofbiz.apache.org" title="ofbiz 官网"> http://ofbiz.apache.org </a>）十多年来的项目实施经验以及原作者的设计和开发。很多的设想和方法论，包括纯粹的关系数据层（并非传统的对象关系映射）以及面向服务的逻辑层，这些主干核心设计Moqui都继承自OFBiz，并且被重新精炼和组织定义。</p>

<p>由于采用了更干净的设计、更简洁的实现，同时使用了更多2001年做OFbiz时未使用的很多更好的第三方类库，Moqui框架的核心代码只有OFBiz核心框架代码的15%左右，并提供了更多有意义的功能和更多的高级工具。</p>

<p>最终，Moqui框架会在构建系统时，自动的帮您把控住一大部分很重要的核心关键部分的实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ 【原创译文】Moqui 概览 — 前言 ]]></title>
    <link href="http://gagaboy.github.io/blog/2014/06/01/moquichap1/"/>
    <updated>2014-06-01T13:47:25+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/06/01/moquichap1</id>
    <content type="html"><![CDATA[<blockquote><p>本系列教程基于作者编写的 <em>MakingAppsWithMoqui-0.41.pdf</em> 文稿，为了便于学习研究，特将此文加上自己的理解进行一些翻译梳理工作。对于一些专业词汇可能限于个人知识面不足和水平较低，不能达意，尽情各位看官谅解！！</p></blockquote>

<!--more-->


<h1>前言</h1>

<hr />

<p>我不是一名专家级的架构开发者，而是和你们大家一样，只是一名职业的应用程序开发人员<em><code>（老戴好谦虚哈 @_@ ! ）</code></em>。我的职业生涯一直围绕着构建和定制化各种不同领域组织的应用系统，并帮助他们进行生产流程管理以及信息自动化管理。</p>

<p>像任何一个工匠一样，一套很好的工具对于应用程序开发人员来说是十分必要的。而我自从1999年涉足商业领域开始，就在寻觅这套最好的开发工具集。但是在当时，企业级Java应用还未到成熟期，市场上也存在很多不同的工具和技术实现在不断验证和巩固一系列的规范和标准。</p>

<p>这当中存在一个问题：构建一个大规模的ERP系统，需要大量的硬件资源支撑才可以运行良好，同时，大厂商的这种企业级应用服务都绑定各自不完备的规范实现，即使有配套的工具和实现技术，对于开发来说也是很难使用的，开发人员备受折磨。并且这些应用在初始化完成之后，客制化和维护也十分困难和昂贵。总之一句话，蛋疼。</p>

<p>各种参照大部分标准的开源替代项目逐渐在市场上浮现出来，并与商业级的产品继续角逐。然而，这只能有助于减少授权的费用，但是对于开发和产品性能而言，帮助并不是很有效。</p>

<p>当然，这里还有很大的改善空间。在2001年，我发起了一个开源项目OFBIZ（The Open For Business Project），它实现了一组自动化信息系统基础的各种行为操作。这意味着其中电子商务、ERP、CRM、MP（_制造资源计划：Manufacturing Resources Plannig）_等都是梳理过并可用的系统模块。基于我在企业级Java应用的经验和独特的想法、设计模式，我设计了一套十分特别的工具集能让人们进行开发工作。这套工具集简化了组织数据的对象映射、逻辑封装以及系统内部使用支持面向服务的设计模式，面向服务逐步变成系统间内部交互的一种规范。</p>

<p>不仅仅是技术开发工具，一个好的应用开发人员还需要一个灵活可扩展、便于理解的数据模型能够定义应用开发中的数据结构和保持数据的一致性。幸运的是，在2001年我早期规划阶段，正好大概开始OFBiz前两个月，Len Silverston出版了《数据模型资源手册，卷一》和《数据模型资源手册，卷二》。这是Silverston对于之前一本同名书（Silverston,Inmon, and Graziano ，1997出版）的高度回顾和总结阐述。</p>

<p>数据模型的理念和模式在上面这两卷书中有介绍，这也是OFBiz的数据模型的规范标准。这些数据模型作为规范实现，在从一个简单的电子商务应用到全功能特性的ERP和CRM系统中有很优雅的表现。并且，作为很多开源项目的基础以及扩展上，数据模型在千万个用户系统中被广泛使用。</p>

<p>OFBiz项目多年来在各种领域中的广泛使用，框架已经扩展积累了很多高度抽象的业务构件。在保持框架稳定的前提下，改进的想法，一些扩展机制还有来源于外部竞争对手的比较等都现实存在。很多的想法都被需要包含在OFBiz中，但是随着开源项目的发展特别是社区用户和贡献者的分解，OFBiz逐步变的基础部分很难去改变。</p>

<p>我对于框架本身有一堆很伟大的并且很关键的改进和扩展列表。随着这些列表逐渐增多，我意识到也许我需要寻求另外一种方式和新的最好工具集去开展下一个阶段，以便解决这些问题。最终结果导致了Moqui这个独立框架的诞生。同时，“地幔”业务构件能提供一种通用的开源、内部交互的应用生态系统的基础组成，它支持商业化的产品和开源一般性的业务构件彼此隔离。</p>

<p>本书将帮助您开始使用Moqui框架，并提供您花费数以月计开发卓越的应用系统的一个参考。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创】使用Intellij IDEA 13 搭建 moqui 开发环境]]></title>
    <link href="http://gagaboy.github.io/blog/2014/05/25/moqui-with-intellij/"/>
    <updated>2014-05-25T17:18:32+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/05/25/moqui-with-intellij</id>
    <content type="html"><![CDATA[<p>都说 <strong>Intellij IDEA</strong> 是个神器，并且老戴童鞋也是用这个开发的moqui。为了方便的学习moqui，偶特地整了下这个号称最智能的IDE的环境，作为自己备忘以及其他感兴趣的童鞋们搭建环境参考（偶滴系mac，win下搭建方式差不多）。</p>

<p>下面一步步的讲解下如何快速让你的开发环境和moqui融合起来。</p>

<!--more-->


<ol>
<li><p>首先选择导入工程，选择工程目录，然后选择下图显示导入 <em>外部Gradle模块</em> ：<br/>
 <img src="http://gagaboy.github.io/moquiImgs/2014-05-25-moqui-with-intellij/import.png" title="import project" alt="import project" /></p></li>
<li><p>这里注意在mac下Intellij 13的gradle 有版本要求，至少 <strong>1.10</strong> 及以上版本：<br/>
 <img src="http://gagaboy.github.io/moquiImgs/2014-05-25-moqui-with-intellij/gradleV10.png" title="gradleVersion" alt="gradleVersion" /></p></li>
<li><p>项目结构配置：基本上不用怎么改动，Intellij 很智能的把一些问题给处理掉了。当然，你也可以自己定制下，我个人是把一些输出目录在工程里面屏蔽了：
 <img src="http://gagaboy.github.io/moquiImgs/2014-05-25-moqui-with-intellij/config.png" title="config" alt="config" /></p></li>
<li><p>然后，就是运行或者调试配置了：这个也很简单，<strong>Edit Configurations…</strong> 下添加 <em>groovy</em> 的配置，每个配置是一个运行脚本。基本上 <em>moqui</em> 只需要四个常用的（ <strong>cleanAll</strong> 、 <strong>build</strong> 、 <strong>load</strong> 、 <strong>run</strong> ）都给配上就可以了：</p>

<p> <img src="http://gagaboy.github.io/moquiImgs/2014-05-25-moqui-with-intellij/runConf.png" title="runConf" alt="runConf" />
 <img src="http://gagaboy.github.io/moquiImgs/2014-05-25-moqui-with-intellij/idea.png" title="idea" alt="idea" /></p></li>
<li><p>基本完成这些配置就可以了，IDE环境已搭建好了，开始你的<strong><em> moqui 之旅 </em></strong>吧&hellip;.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【原创】HEMP Light 文档汉化]]></title>
    <link href="http://gagaboy.github.io/blog/2014/05/25/translate-hemplight/"/>
    <updated>2014-05-25T16:58:36+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/05/25/translate-hemplight</id>
    <content type="html"><![CDATA[<p>懒得一章章的贴了，折腾</p>

<p>需要的直接点击下载看吧：
<a href="http://gagaboy.github.io/moquiFiles/HempLight%E6%B1%89%E5%8C%96%E7%89%88%EF%BC%88Beta1%EF%BC%89.pdf" title="HempLight汉化版（Beta1）.pdf">HempLight汉化版（Beta1）.pdf</a> </p>

<p>后面可能优先先写教程和moqui框架分析之类的学习分享文档吧，逐步再去把HEMP Best汉化掉</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[moqui文档资源分享]]></title>
    <link href="http://gagaboy.github.io/blog/2014/05/25/shareddocs/"/>
    <updated>2014-05-25T15:33:04+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/05/25/shareddocs</id>
    <content type="html"><![CDATA[<p>来源于老戴的官网和Linkin的资源：</p>

<p>（一） 首先是老戴的多年业务经验和架构分析方法的介绍，个人觉得这是个理论基础。主要是面对需求、设计分析至实现等一系列过程的方法，偏向于软件开发主管或项目经理之类的角色，当然技术人员学习也是个很好的手段。由于是英文的逐步会在博客中将其汉化，并共享出来。</p>

<!--more-->


<p>这部分主要是：</p>

<p><a href="http://gagaboy.github.io/moquiFiles/HempBestPractices20090620.pdf" title="HempBestPractices20090620.pdf"> HempBestPractices20090620.pdf </a></p>

<p><a href="http://gagaboy.github.io/moquiFiles/HempLight20090620.pdf" title="HempLight20090620.pdf"> HempLight20090620.pdf </a></p>

<p>（二） 其次是老戴关于moqui的部分开发和架构介绍，个人觉得快速入门看下IntroductionToMoquiFramework-1.0.1.pdf，然后再去系统的看下MakingAppsWithMoqui.pdf，会有个更直观全面的moqui框架的了解。</p>

<p>这里有点偷懒，暂时对于MakingAppsWithMoqui.pdf做了中文单词的批注，后面会等老戴写完之后推出完整的汉化文档。</p>

<p>文档如下：</p>

<p><a href="http://gagaboy.github.io/moquiFiles/IntroductionToMoquiFramework-1.0.1.pdf" title="IntroductionToMoquiFramework-1.0.1.pdf">IntroductionToMoquiFramework-1.0.1.pdf</a> </p>

<p><a href="http://gagaboy.github.io/moquiFiles/MakingAppsWithMoqui.pdf" title="MakingAppsWithMoqui.pdf">MakingAppsWithMoqui.pdf</a></p>

<p>后面开始陆续推出汉化内容：HempLight20090620.pdf的内容，大部分已经汉化完成，在进行进一步的核对工作。由于本人经验有限，难免翻译的水平和理解有欠缺，各位看官可以结合原文进行阅读理解，后面译文只是作为参考使用，谢谢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[moqui 入门系列 -- 前言乱喷 + 网络资源链接]]></title>
    <link href="http://gagaboy.github.io/blog/2014/05/20/my-words/"/>
    <updated>2014-05-20T17:06:14+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/05/20/my-words</id>
    <content type="html"><![CDATA[<p>moqui是啥，简单来说它是个框架，作者谦虚的称它是个工具集。从我的观点，moqui天生就是为了企业级应用而生的全栈式框架。可能会有很多大牛开始喷我了，你懂架构不？你知道啥啥啥技术不？？对不起，我确实是理论派转战开始搞技术的，所以我会先看你的整体思路和理念，而不是你支持restful，简单的路由转换，注入或者是MVC&hellip;对于我来说，这些都不重要。</p>

<!--more-->


<p>  鄙人认为，好的框架是啥，约定优先编码，然后就是业务高度抽象，同时有MDD的feel，能快速开发和便捷维护。这是个很虚的概念，很多牛人估计又要跳出来了，如同小日本穿着黑色风衣，戴着墨镜的怪大叔遇见口爱小MM的时候一样，嚣张的亮出一条自认为很炫的“东西”（自己博客的链接），然后大吼一声：看我的家伙多么多么牛X。。。我怎么怎么设计约定的，你们按照我的方式这么弄再那么弄，可以出来弄出来很多很多的东西。。。我的意思不是调侃这些牛人，而是大家关注点不同，框架和平台的差异，我认为你初期设想多少，你才能走多远。</p>

<p>好吧，扯远了，延续刚才的话题：约定优先编码。很多人会以各种方式告诉我他们的约定是啥或者啥叫约定，我会给你鼓掌，然后转身就忘了。所以，我觉得：</p>

<ol>
<li>约定是经过业务经验累积和高度抽象出来的大家公认的原则。区别于一些大牛自己设想的某些规则。moqui很多的业务抽象和设计理念来源于OAGIS标准，不知道的可以去google一下（那怕那个啥大和谐它，goagent也只用它。毕竟度娘和女优程序员的差异&hellip;嘿嘿  你懂的&hellip;）moqui有个很有名的&quot;大哥&quot;，估计很多大牛都知道&mdash;OFBIZ,不知道的同样去找下google。有&quot;大哥&quot;罩着，用起来首先心理上很爽，感觉靠谱了。</li>
<li>约定要一看即了，而无需过多的解释和培训。虽然很多时候是噱头，但是如果你看了moqui，代码结构，然后里面的内容。我觉得新手都知道这是一堆配置（其实就是代码），而且能猜出来这是做啥的。我觉得能具备一定自描述能力的代码就是好代码，moqui正是如此。</li>
</ol>


<p>首先，我觉得moqui更适合快速开发，同时具备一定开发能力的业务专家能通过他迅速的配置出自己的原型，表述自己的思想，但并不是说它只是个原型构建系统。至少目前它具备了：基本的ERP的开发能力（具体权限模型需完善）、ESB、多租户（想玩Saas么？？可以尝试下）、安全策略（OWASP ESAPI ）、资源管理&hellip;</p>

<p>moqui的架构看我的头像，好吧，希望作者老戴不会告我侵权感觉很多人对于moqui还是云里雾里，好吧，我承认这篇不说太多moqui的东西，不然你们就不会看后面的系列了，哈哈。</p>

<p>先放出些moqui相关的资料，这里也感谢群里的阿超提供的老戴的圈子地址哈。</p>

<p>moqui官方地址：<a href="http://www.moqui.org/">http://www.moqui.org/</a></p>

<p>moqui的源码：<a href="https://github.com/jonesde">https://github.com/jonesde</a> （还有基于moqui的地幔和ofbiz的迁移演示部分） </p>

<p>作者老戴的官方网站：<a href="http://www.dejc.com/">http://www.dejc.com/</a></p>

<p>moqui最新资讯：<a href="http://www.linkedin.com/groups/Moqui-Framework-4640689">http://www.linkedin.com/groups/Moqui-Framework-4640689</a></p>

<p>后面逐步开展moqui的入门教程编写工作，有兴趣的欢迎联系我，因为所有资料都是E文的，与其那么多感兴趣的人一起蛋疼，不如蛋疼几个人，让其他人少疼一点。。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个关于MOQUI的学习博客]]></title>
    <link href="http://gagaboy.github.io/blog/2014/05/18/bo-ke-kai-zhang-liao/"/>
    <updated>2014-05-18T19:56:48+08:00</updated>
    <id>http://gagaboy.github.io/blog/2014/05/18/bo-ke-kai-zhang-liao</id>
    <content type="html"><![CDATA[<p>博客主要内容关于moqui框架的使用，后面会逐步推出教程以及框架解析。</p>

<p>相应的ITeye上面的内容我也会迁移过来，并以此博客为主，希望大家一起交流学习共勉！！</p>
]]></content>
  </entry>
  
</feed>
